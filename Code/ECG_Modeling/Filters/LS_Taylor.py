# _____________________________________________________________
# author: T. Locher, tilocher@ethz.ch
# _____________________________________________________________
import time

import matplotlib.pyplot as plt
import torch
from tqdm import trange

from Code.ECG_Modeling.SystemModels.ECG_model import ECG_signal, GetNextState, pi
import numpy as np
from Code.ECG_Modeling.Filters.Extended_RTS_Smoother import Extended_rts_smoother
from Code.ECG_Modeling.SystemModels.Extended_sysmdl import SystemModel
from Code.ECG_Modeling.Filters.EKF import ExtendedKalmanFilter

torch.set_default_dtype(torch.float32)

class LS_Taylor():

    def __init__(self, taylor_order = 1):

        assert taylor_order >= 1, 'Taylor order must be at least 1'
        self.taylor_order = taylor_order



    def f(self,x,t):
        x_input = torch.tensor(np.array([x.detach().numpy() ** i for i in range(1, self.taylor_order + 1)])).T.float()
        return (x_input @ self.coefficients[int(t)]).float()

    def df(self,x,t):
        return torch.atleast_2d(self.coefficients[t,0])

    def h(self,x,t):
        return x

    # Evolution function of the true system
    def f_true(self,x, t):
        return GetNextState(x, t, self.deltaT, self.order)

    # Observation function of the true system
    def h_true(self,x, t):
        return x[self.obs, :]


    def fit(self, data:torch.tensor, batch_first = True):

        if not batch_first: data = torch.transpose(data,0,-1)

        data = data.squeeze()

        time_steps = data.shape[-1]

        coefficients = torch.ones((time_steps,self.taylor_order))

        for t in range(1,time_steps):

            input_tensor = torch.tensor(np.array([data[:,t].numpy()**i for i in range(1,self.taylor_order + 1)])).T
            target_tensor = data[:,t].unsqueeze(1)
            coefficients[t] = torch.linalg.lstsq(target_tensor,input_tensor).solution

        self.coefficients = coefficients.float()
        return coefficients




    def FilterSytheticModel(self,ecg_signal: ECG_signal, q = None,r = None , synthetic = True, Plot = False):
        """
        Use a RTS filter to filter a signal generated by the ECG_Signal class
        :param ecg_signal: ECG_signal class
        :return: RTS filtered states
        """

        # Get parameters of the data
        self.deltaT = deltaT = ecg_signal.deltaT
        self.order = order = ecg_signal.order
        data = ecg_signal.traj
        data_noisy = ecg_signal.traj_noisy
        if q == None:
            q = np.sqrt(ecg_signal.q_2)

        if r == None:
            r = np.sqrt(ecg_signal.r_2)

        T = ecg_signal.num_steps
        Batch_size = ecg_signal.batch_size

        self.obs = obs = 2 if synthetic else 0

        # Create the system model
        TrueSystemModel = SystemModel(self.f_true,q * deltaT, self.h_true, r, T , T, 4, 1)

        if  isinstance(r,float):
            TrueSystemModel.UpdateCovariance_Matrix(TrueSystemModel.Q,r)

        # Set priors
        m1x0 = torch.atleast_2d(torch.tensor([1., 0, 0, 2 * pi])).T
        m2x0 = torch.eye(4)
        TrueSystemModel.InitSequence(m1x0,m2x0)

        KF = ExtendedKalmanFilter(TrueSystemModel)
        KF.InitSequence(TrueSystemModel.m1x_0, TrueSystemModel.m2x_0)
        RTS = Extended_rts_smoother(TrueSystemModel)

        MSE_RTS_linear_arr = torch.empty(Batch_size)
        loss_rts = torch.nn.MSELoss(reduction='mean')

        error_cov = torch.empty((Batch_size, 4, 4, T))
        error_cov_prior = torch.empty((Batch_size, 4, 4, T))


        filtered_states = torch.empty((Batch_size, 1,4 , T))

        # Run Loop

        with torch.no_grad():
            for j in trange(Batch_size):

                KF.GenerateSequence(data_noisy[j, obs, :].reshape((1,-1)), KF.T_test)
                RTS.GenerateSequence(KF.x, KF.sigma, RTS.T_test)
                MSE_RTS_linear_arr[j] = loss_rts(RTS.s_x[obs,:], data[j, obs, :]).item()
                filtered_states[j] = RTS.s_x
                error_cov[j] = RTS.s_sigma
                error_cov_prior[j] = RTS.s_sigma_prior

        if Plot:
            plt.plot(filtered_states[-1,:,obs].squeeze(), label='Filtered data, evolution unknown')
            plt.plot(ecg_signal.traj[-1, obs].squeeze(), label='Noiseless data', alpha=0.8)
            plt.plot(ecg_signal.traj_noisy[-1, obs].squeeze(), label='noisy data', alpha=0.3)

            # if synthetic:
            #     x_full, _, _ = self.FilterTrueModel(ecg_signal)
            #     plt.plot(x_full[-1, :, 2].squeeze(), label='Filter with full knowledge', alpha=0.9)
            # plt.plot()
            plt.legend()
            # plt.savefig('..\\Plots\\Data_fit_{}.pdf'.format(time.time_ns()))
            plt.show()

        print('Mean RTS loss True Model: {} [dB]'.format(10*torch.log10(MSE_RTS_linear_arr.mean()).item()))
        print('Loss without filter: {} [dB]'.format(10 * torch.log10(loss_rts(data[:,obs],data_noisy[:,obs])).item()))
        no_filter_loss = 10 * torch.log10(loss_rts(data[:,obs],data_noisy[:,obs])).item()
        self.TrueRTS = RTS

        return filtered_states, error_cov, error_cov_prior, MSE_RTS_linear_arr, no_filter_loss

    def FilterEstimatedModel(self, ecg_signal: ECG_signal ,ssModel, Q, R, Plot = '', synthetic = False):

        # Get parameters of the data
        data = ecg_signal.traj
        data_noisy = ecg_signal.traj_noisy

        T = ecg_signal.num_steps
        Batch_size = ecg_signal.batch_size

        obs = 2 if synthetic else 0



        KF = ExtendedKalmanFilter(ssModel)
        KF.InitSequence(ssModel.m1x_0, ssModel.m2x_0)
        RTS = Extended_rts_smoother(ssModel)

        MSE_RTS_linear_arr = torch.empty(Batch_size)
        loss_rts = torch.nn.MSELoss(reduction='mean')



        filtered_states = torch.empty((Batch_size,ssModel.m,1,T))
        error_cov = torch.empty((Batch_size,ssModel.m,ssModel.m,T))
        error_cov_prior = torch.empty((Batch_size, ssModel.m, ssModel.m, T))
        # Run Loop

        with torch.no_grad():
            for j in trange(Batch_size):

                KF.GenerateSequence(data_noisy[j,obs].reshape((1,-1)), KF.T_test)
                RTS.GenerateSequence(KF.x, KF.sigma, RTS.T_test)
                MSE_RTS_linear_arr[j] = loss_rts(RTS.s_x, data[j, obs, :T]).item()
                filtered_states[j] = RTS.s_x
                error_cov[j] = RTS.s_sigma
                error_cov_prior[j] = RTS.s_sigma_prior

        print('Mean RTS loss Estimated Model: {} [dB]'.format(10*torch.log10(MSE_RTS_linear_arr.mean()).item()))
        self.EstRTS = RTS

        if Plot == 'Plot' or Plot == 'Save':
            plt.plot(ecg_signal.traj[-1,obs].squeeze(),label = 'Noiseless data',alpha = 0.8, color='g')
            plt.plot(ecg_signal.traj_noisy[-1,obs].squeeze(), label= 'noisy data',alpha = 0.3, color = 'r')
            if synthetic:
                x_full,_,_,_,_ = self.FilterSytheticModel(ecg_signal)
                plt.plot(x_full[-1,:,2].squeeze(), label = 'Filter with full knowledge', alpha = 0.9, color = 'c')
            plt.plot(filtered_states[-1].squeeze(),label = 'Filtered data, evolution unknown',color='b')



            plt.legend()
            if Plot == 'Save':
                plt.savefig('..\\Plots\\Data_fit_{}.pdf'.format(time.time_ns()))
            plt.show()

        return filtered_states,error_cov,error_cov_prior, MSE_RTS_linear_arr

    def EM(self,ecg_model: ECG_signal,ssModel, q_2, r_2, synthetic = False, Plot = 'Plot'):

        m = ssModel.m
        n = ssModel.n


        Q = q_2 * torch.eye(m)
        R = r_2 * torch.eye(n)

        losses = []

        self.obs = obs = 2 if synthetic else 0
        # m = 4 if synthetic else 1
        m = 1

        deltaT = ecg_model.deltaT
        T = ecg_model.num_steps

        if synthetic:

            _,_,_,true_kf_loss, no_filter_loss = self.FilterSytheticModel(ecg_signal)

            true_kf_loss = 10*torch.log10(true_kf_loss.mean()).item()



        with torch.no_grad():

            batch_size = ecg_model.batch_size - 1
            obs_states = ecg_model.traj_noisy[:,obs,:].reshape((ecg_model.batch_size,1,1,-1))

            for i in range(10):

                # Create the system model
                # EstSystemModel = SystemModel(self.f, deltaT * Q, self.h, R, T, T, 1, 1)
                EstSystemModel.UpdateCovariance_Matrix(deltaT ** 2 * Q, R)
                EstSystemModel.setFJac(self.df)

                # Set priors
                m1x0 = torch.atleast_2d(torch.tensor(0.))
                m2x0 = torch.atleast_2d(torch.tensor(1.))
                EstSystemModel.InitSequence(m1x0, m2x0)

                filtered_states,error_cov,error_cov_prior,loss = self.FilterEstimatedModel(ecg_model,EstSystemModel,
                                                                                           Q ,R ,
                                                                                           synthetic=synthetic ,
                                                                                           Plot= Plot)

                error_cov = error_cov.mean(0).reshape((m,m,-1))
                error_cov_prior = error_cov_prior.mean(0).reshape((m,m,-1))
                E_xx = torch.einsum('bqmt,tnqb->mnt',(filtered_states,filtered_states.T))/batch_size


                U_xx = (E_xx + error_cov).mean(-1)
                U_yx = (torch.einsum('bqnt,tmqb->nmt',(obs_states,filtered_states.T))/batch_size).mean(-1)
                U_yy = (torch.einsum('bqnt,tqmb->nmt',(obs_states,obs_states.T))/batch_size).mean(-1)

                C = U_yx @ torch.inverse(U_xx)
                R = U_yy - C @ U_yx.T #- U_yx @ C.T + C @ U_xx @ C.T
                # r = torch.sqrt(R)



                V_xx = (E_xx[:,:,:-1] + error_cov[:,:,:-1])#.mean(-1)
                V_x1x1 = (E_xx[:,:,1:] + error_cov[:,:,1:])#.mean(-1)
                V_x1x = (((torch.einsum('bmqt,tqnb->mnt', (filtered_states[:,:,:,1:], filtered_states[:,:,:,:-1].T))/batch_size)
                          + error_cov_prior[:,:,:-1]).reshape((m,m,-1)))#.mean(-1)

                A = torch.bmm(V_x1x.T, torch.inverse(V_xx.T)).T
                # A = V_x1x @ torch.inverse(V_xx.T).T



                # self.coefficients[1:] = A.squeeze(0).T
                # A = A.unsqueeze(0)
                # V_x1x = V_x1x.unsqueeze(0)
                V_xx = V_xx.unsqueeze(0)

                # Q = (V_x1x1 - torch.bmm(A.T,V_x1x.T).T).mean()



                print('q: {}'.format(Q.item()))
                print('r^2: {}'.format(R.item()))
                # if torch.abs(r - r_prev) <= 1e-6:
                #     break

                # q_prev = q
                # r_prev = r

                losses.append(10*torch.log10(loss.mean()).item())

            plt.plot(losses,'*g', label = 'loss per iteration')
            if synthetic:
                plt.plot(np.ones_like(losses).T * true_kf_loss, label = 'KF loss full knowledge')
                plt.plot(np.ones_like(losses).T * no_filter_loss, label = 'Loss without filter')
            plt.grid()
            plt.xlabel('Iteration')
            plt.ylabel('Loss [dB]')
            plt.title('EM optimization convergence')
            plt.legend()
            plt.savefig('..\\Plots\\EM_convergence_plot.pdf')
            plt.show()


if __name__ == '__main__':
    import warnings
    warnings.filterwarnings("ignore")

    # Load dataset
    ecg_signal = torch.load('..\\Datasets\\Synthetic\\17.06.22--14.32.pt')

    # Get noisy data and noiseless data
    data_noisy = ecg_signal.traj_noisy[:,2,:]
    data_noiseless = ecg_signal.traj[:,2,:]


    def f(x,t):
        return x
    def h(x):
        return x[:3]

    ToyModel = SystemModel(f,1,h,1,100,100,4,3)
    ToyModel.InitSequence(torch.randn((4)) , torch.randn((4,4))**2)
    ToyModel.GenerateSequence(ToyModel.Q,ToyModel.R,ToyModel.T)

    toy_ecg = ECG_signal()
    toy_ecg.CreateFromData(ToyModel.x,ToyModel.y)



    # Create a LS Taylor model of order n
    taylor = LS_Taylor(2)

    # Fit coefficients to data
    taylor.fit(data_noisy)

    # EM for Noise fit
    taylor.EM(ecg_signal, ecg_signal.q_2,1, synthetic=True)




